# Implement a program to find the maximum element in a stack in O(1) time (requires an auxiliary stack).

## Implement a program to find the maximum element in a stack in O(1) time.
### Approach:
    - Use two stacks:
        1. mainStack: stores actual elements.
        2. maxStack: stores the maximum element so far at each level.
    - On push(x):
        * Push x to mainStack.
        * If maxStack is empty OR x >= top(maxStack), push x to maxStack.
    - On pop():
        * Pop from mainStack.
        * If popped element == top(maxStack), pop from maxStack as well.
    - getMax(): return top(maxStack).
    âœ… All operations in O(1).

```c

#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int top;
    int capacity;
    int* arr;
} Stack;

// Create stack
Stack* createStack(int capacity) {
    Stack* stack = (Stack*)malloc(sizeof(Stack));
    stack->capacity = capacity;
    stack->top = -1;
    stack->arr = (int*)malloc(capacity * sizeof(int));
    return stack;
}

// Check empty
int isEmpty(Stack* stack) {
    return stack->top == -1;
}

// Push
void push(Stack* stack, int value) {
    if (stack->top == stack->capacity - 1) {
        printf("Stack Overflow!\n");
        return;
    }
    stack->arr[++stack->top] = value;
}

// Pop
int pop(Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack Underflow!\n");
        return -1;
    }
    return stack->arr[stack->top--];
}

// Peek
int peek(Stack* stack) {
    if (isEmpty(stack)) return -1;
    return stack->arr[stack->top];
}

typedef struct {
    Stack* mainStack;
    Stack* maxStack;
} MaxStack;

// Create MaxStack
MaxStack* createMaxStack(int capacity) {
    MaxStack* ms = (MaxStack*)malloc(sizeof(MaxStack));
    ms->mainStack = createStack(capacity);
    ms->maxStack = createStack(capacity);
    return ms;
}

// Push with max tracking
void pushMax(MaxStack* ms, int value) {
    push(ms->mainStack, value);

    if (isEmpty(ms->maxStack) || value >= peek(ms->maxStack)) {
        push(ms->maxStack, value);
    }
    printf("%d pushed\n", value);
}

// Pop with max tracking
int popMax(MaxStack* ms) {
    if (isEmpty(ms->mainStack)) {
        printf("Stack Underflow!\n");
        return -1;
    }
    int popped = pop(ms->mainStack);

    if (popped == peek(ms->maxStack)) {
        pop(ms->maxStack);
    }

    return popped;
}

// Get current maximum in O(1)
int getMax(MaxStack* ms) {
    if (isEmpty(ms->maxStack)) {
        printf("Stack is empty!\n");
        return -1;
    }
    return peek(ms->maxStack);
}

int main() {
    MaxStack* ms = createMaxStack(10);

    pushMax(ms, 10);
    pushMax(ms, 20);
    pushMax(ms, 5);
    printf("Current Max: %d\n", getMax(ms));

    popMax(ms);
    printf("After pop, Current Max: %d\n", getMax(ms));

    pushMax(ms, 50);
    printf("After pushing 50, Current Max: %d\n", getMax(ms));

    return 0;
}


```

## Sample Output:

```c

10 pushed
20 pushed
5 pushed
Current Max: 20
After pop, Current Max: 20
50 pushed
After pushing 50, Current Max: 50

```
