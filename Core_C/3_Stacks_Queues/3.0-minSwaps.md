# Implement a program to find the minimum number of swaps to sort an array, often leveraging ideas related to cycles.

## Approach:
 - Pair each element with its index.
 - Sort the array by values while keeping original indices.
 - Traverse array to find cycles:
    * If an element is not in the correct position and not visited, trace its cycle.
    * Number of swaps needed for a cycle of length k = (k - 1).
 - Sum over all cycles.
    ✅ Time Complexity: O(N log N) (due to sorting).
    ✅ Space Complexity: O(N) (for visited array + pair indexing).

```c

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef struct {
    int value;
    int index;
} Pair;

// Comparator for qsort
int compare(const void* a, const void* b) {
    return ((Pair*)a)->value - ((Pair*)b)->value;
}

// Function to find minimum swaps
int minSwaps(int arr[], int n) {
    Pair* arrPos = (Pair*)malloc(n * sizeof(Pair));
    bool* visited = (bool*)malloc(n * sizeof(bool));

    // Store array elements with their original indices
    for (int i = 0; i < n; i++) {
        arrPos[i].value = arr[i];
        arrPos[i].index = i;
        visited[i] = false;
    }

    // Sort array by value
    qsort(arrPos, n, sizeof(Pair), compare);

    int swaps = 0;

    // Traverse array elements
    for (int i = 0; i < n; i++) {
        // Already visited or already in correct place
        if (visited[i] || arrPos[i].index == i) 
            continue;

        // Find cycle size
        int cycle_size = 0;
        int j = i;

        while (!visited[j]) {
            visited[j] = true;
            j = arrPos[j].index;
            cycle_size++;
        }

        if (cycle_size > 1) {
            swaps += (cycle_size - 1);
        }
    }

    free(arrPos);
    free(visited);
    return swaps;
}

int main() {
    int arr[] = {4, 3, 2, 1};
    int n = sizeof(arr) / sizeof(arr[0]);

    printf("Minimum number of swaps required: %d\n", minSwaps(arr, n));

    return 0;
}


```

# Example Walkthrough

- For arr = {4, 3, 2, 1}

- Sorted array = {1, 2, 3, 4}

### Cycles:

- 4 → 1 → 4 (cycle length = 2 → 1 swap)

- 3 → 2 → 3 (cycle length = 2 → 1 swap)

- Total swaps = 2 ✅

# Sample Output:

```c

Minimum number of swaps required: 2

```
